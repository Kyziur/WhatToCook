@import "_variables";

.d-flex {
    display: flex;
}

.d-grid {
    display: grid;
}

.justify-center {
    justify-content: center;
}

.btn {
    color: black;
    border: 0;
    padding: 0.5rem 1rem;
    overflow: hidden;

    border-radius: 1rem 1rem 1rem 1rem;
    display: inline-block;
    background-color: white;


    &-green {
        color: $white;
        background-color: $blue-background;

        &:hover {
            background-color: $darker-blue-background;
            color: $white;
        }
    }
}


$direction: (
    "right":"r",
    "left":"l",
    "top":"t",
    "bottom": "b"
);

$length: (
    0,
    1,
    2,
    3,
    4
);

@each $len in $length {
    .p-#{$len} {
        padding: #{$len/2}rem;
    }

    .m-#{$len} {
        margin: #{$len/2}rem;
    }
}

@each $dir,
$shortDir in $direction {
    @each $len in $length {
        .p#{$shortDir}-#{$len} {
            padding-#{$dir}: #{$len/2}rem;
        }

        .m#{$shortDir}-#{$len} {
            margin-#{$dir}: #{$len/2}rem;
        }
    }
}

/// Mixin to manage responsive breakpoints
/// @author Kitty Giraudel
/// @param {String} $breakpoint - Breakpoint name
/// @require $breakpoints
@mixin respond-to($breakpoint) {

    // If the key exists in the map
    @if map-has-key($breakpoints, $breakpoint) {

        // Prints a media query based on the value
        @media #{inspect(map-get($breakpoints, $breakpoint))} {
            @content;
        }
    }

    // If the key doesn't exist in the map
    @else {
        @warn "Unfortunately, no value could be retrieved from `#{$breakpoint}`. "
        +"Available breakpoints are: #{map-keys($breakpoints)}.";
    }
}